'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lodash = require('lodash.isequal');

var _lodash2 = _interopRequireDefault(_lodash);

var _infiniteHelpers = require('./utils/infiniteHelpers');

var _infiniteHelpers2 = _interopRequireDefault(_infiniteHelpers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var timeScrollStateLastsForAfterUserScrolls = 150;

var Infinite = function (_React$Component) {
	_inherits(Infinite, _React$Component);

	function Infinite(props) {
		_classCallCheck(this, Infinite);

		var _this = _possibleConstructorReturn(this, (Infinite.__proto__ || Object.getPrototypeOf(Infinite)).call(this, props));

		_initialiseProps.call(_this);

		var nextInternalState = _this.recomputeInternalStateFromProps(props);

		_this.computedProps = nextInternalState.computedProps;
		_this.utils = nextInternalState.utils;

		var state = nextInternalState.newState;
		state.scrollTimeout = undefined;
		state.isScrolling = false;

		_this.state = state;
		return _this;
	}

	_createClass(Infinite, [{
		key: 'componentWillReceiveProps',


		// shouldComponentUpdate(nextProps, nextState) {
		// 	console.log(!isEqual(this.props.children, nextProps.children));
		// 	return this.props.containerHeight !== nextProps.containerHeight
		// 		|| this.props.elementHeight !== nextProps.elementHeight
		// 		|| !isEqual(this.props.data, nextProps.data)
		// 		// || !isEqual(this.props.children, nextProps.children)
		// 		|| !isEqual(this.state, nextState);
		// }

		value: function componentWillReceiveProps(nextProps) {
			var nextInternalState = this.recomputeInternalStateFromProps(nextProps);

			this.computedProps = nextInternalState.computedProps;
			this.utils = nextInternalState.utils;

			this.setState(nextInternalState.newState);
		}
	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var displayables = void 0;
			if (this.state.dataLength > 1) {
				displayables = this.computedProps.children.slice(this.state.displayIndexStart, this.state.displayIndexEnd + 1);
			} else {
				displayables = this.computedProps.children;
			}

			var infiniteScrollStyles = {};
			if (this.state.isScrolling) {
				infiniteScrollStyles.pointerEvents = 'none';
			}

			var topSpacerHeight = this.state.infiniteComputer.getTopSpacerHeight(this.state.displayIndexStart),
			    bottomSpacerHeight = this.state.infiniteComputer.getBottomSpacerHeight(this.state.displayIndexEnd);

			// topSpacer and bottomSpacer take up the amount of space that the
			// rendered elements would have taken up otherwise
			return _react2.default.createElement(
				'div',
				{
					className: this.computedProps.className,
					ref: function ref(c) {
						_this2.scrollable = c;
					},
					style: this.utils.buildScrollableStyle(),
					onScroll: this.utils.nodeScrollListener
				},
				_react2.default.createElement(
					'div',
					{
						ref: function ref(c) {
							_this2.smoothScrollingWrapper = c;
						},
						style: infiniteScrollStyles
					},
					_react2.default.createElement('div', {
						ref: function ref(c) {
							_this2.topSpacer = c;
						},
						style: _infiniteHelpers2.default.buildHeightStyle(topSpacerHeight)
					}),
					displayables,
					_react2.default.createElement('div', {
						ref: function ref(c) {
							_this2.bottomSpacer = c;
						},
						style: _infiniteHelpers2.default.buildHeightStyle(bottomSpacerHeight)
					})
				)
			);
		}
	}]);

	return Infinite;
}(_react2.default.Component);

Infinite.propTypes = {
	children: _propTypes2.default.any,
	data: _propTypes2.default.array,
	elementHeight: _propTypes2.default.number.isRequired,
	containerHeight: _propTypes2.default.number.isRequired,
	className: _propTypes2.default.string,
	styles: _propTypes2.default.shape({
		scrollableStyle: _propTypes2.default.object
	}).isRequired,
	onVisibleChange: _propTypes2.default.func
};
Infinite.defaultProps = {
	className: '',
	styles: {},
	onVisibleChange: function onVisibleChange() {}
};

var _initialiseProps = function _initialiseProps() {
	var _this3 = this;

	this.generateComputedUtilityFunctions = function () {
		var utilities = {};

		utilities.nodeScrollListener = _this3.infiniteHandleScroll;
		utilities.getScrollTop = function () {
			return _this3.scrollable ? _this3.scrollable.scrollTop : 0;
		};

		utilities.setScrollTop = function (top) {
			if (_this3.scrollable) {
				_this3.scrollable.scrollTop = top;
			}
		};
		utilities.scrollShouldBeIgnored = function (event) {
			return event.target !== _this3.scrollable;
		};

		utilities.buildScrollableStyle = function () {
			return Object.assign({}, {
				height: _this3.computedProps.containerHeight,
				overflowX: 'hidden',
				overflowY: 'scroll',
				WebkitOverflowScrolling: 'touch'
			}, _this3.computedProps.styles.scrollableStyle || {});
		};

		return utilities;
	};

	this.recomputeInternalStateFromProps = function (props) {
		var computedProps = _infiniteHelpers2.default.generateComputedProps(props);
		var utils = _this3.generateComputedUtilityFunctions();

		var newState = {};

		newState.dataLength = computedProps.data.length;
		newState.infiniteComputer = _infiniteHelpers2.default.createInfiniteComputer(computedProps.elementHeight, computedProps.data);

		newState.preloadBatchSize = computedProps.preloadBatchSize;
		newState.preloadAdditionalHeight = computedProps.preloadAdditionalHeight;

		newState = Object.assign(newState, _infiniteHelpers2.default.recomputeApertureStateFromOptionsAndScrollTop(newState, utils.getScrollTop()));

		return {
			computedProps: computedProps,
			utils: utils,
			newState: newState
		};
	};

	this.infiniteHandleScroll = function (e) {
		if (_this3.utils.scrollShouldBeIgnored(e)) {
			return;
		}

		_this3.handleScroll(_this3.utils.getScrollTop());
	};

	this.manageScrollTimeouts = function () {
		// Maintains a series of timeouts to set this.state.isScrolling
		// to be true when the element is scrolling.

		if (_this3.state.scrollTimeout) {
			clearTimeout(_this3.state.scrollTimeout);
		}

		var that = _this3,
		    scrollTimeout = setTimeout(function () {
			that.setState({
				isScrolling: false,
				scrollTimeout: undefined
			});
		}, timeScrollStateLastsForAfterUserScrolls);

		_this3.setState({
			isScrolling: true,
			scrollTimeout: scrollTimeout
		});
	};

	this.handleScroll = function (scrollTop) {
		_this3.manageScrollTimeouts();

		var newApertureState = _infiniteHelpers2.default.recomputeApertureStateFromOptionsAndScrollTop(_this3.state, scrollTop);
		// this.props.onVisibleChange(newApertureState);
		_this3.setState(Object.assign({}, newApertureState));
	};
};

exports.default = Infinite;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXp5TG9hZC9yZWFjdC1pbmZpbml0ZS5qc3giXSwibmFtZXMiOlsidGltZVNjcm9sbFN0YXRlTGFzdHNGb3JBZnRlclVzZXJTY3JvbGxzIiwiSW5maW5pdGUiLCJwcm9wcyIsIm5leHRJbnRlcm5hbFN0YXRlIiwicmVjb21wdXRlSW50ZXJuYWxTdGF0ZUZyb21Qcm9wcyIsImNvbXB1dGVkUHJvcHMiLCJ1dGlscyIsInN0YXRlIiwibmV3U3RhdGUiLCJzY3JvbGxUaW1lb3V0IiwidW5kZWZpbmVkIiwiaXNTY3JvbGxpbmciLCJuZXh0UHJvcHMiLCJzZXRTdGF0ZSIsImRpc3BsYXlhYmxlcyIsImRhdGFMZW5ndGgiLCJjaGlsZHJlbiIsInNsaWNlIiwiZGlzcGxheUluZGV4U3RhcnQiLCJkaXNwbGF5SW5kZXhFbmQiLCJpbmZpbml0ZVNjcm9sbFN0eWxlcyIsInBvaW50ZXJFdmVudHMiLCJ0b3BTcGFjZXJIZWlnaHQiLCJpbmZpbml0ZUNvbXB1dGVyIiwiZ2V0VG9wU3BhY2VySGVpZ2h0IiwiYm90dG9tU3BhY2VySGVpZ2h0IiwiZ2V0Qm90dG9tU3BhY2VySGVpZ2h0IiwiY2xhc3NOYW1lIiwic2Nyb2xsYWJsZSIsImMiLCJidWlsZFNjcm9sbGFibGVTdHlsZSIsIm5vZGVTY3JvbGxMaXN0ZW5lciIsInNtb290aFNjcm9sbGluZ1dyYXBwZXIiLCJ0b3BTcGFjZXIiLCJidWlsZEhlaWdodFN0eWxlIiwiYm90dG9tU3BhY2VyIiwiQ29tcG9uZW50IiwicHJvcFR5cGVzIiwiYW55IiwiZGF0YSIsImFycmF5IiwiZWxlbWVudEhlaWdodCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJjb250YWluZXJIZWlnaHQiLCJzdHJpbmciLCJzdHlsZXMiLCJzaGFwZSIsInNjcm9sbGFibGVTdHlsZSIsIm9iamVjdCIsIm9uVmlzaWJsZUNoYW5nZSIsImZ1bmMiLCJkZWZhdWx0UHJvcHMiLCJnZW5lcmF0ZUNvbXB1dGVkVXRpbGl0eUZ1bmN0aW9ucyIsInV0aWxpdGllcyIsImluZmluaXRlSGFuZGxlU2Nyb2xsIiwiZ2V0U2Nyb2xsVG9wIiwic2Nyb2xsVG9wIiwic2V0U2Nyb2xsVG9wIiwidG9wIiwic2Nyb2xsU2hvdWxkQmVJZ25vcmVkIiwiZXZlbnQiLCJ0YXJnZXQiLCJPYmplY3QiLCJhc3NpZ24iLCJoZWlnaHQiLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJXZWJraXRPdmVyZmxvd1Njcm9sbGluZyIsImdlbmVyYXRlQ29tcHV0ZWRQcm9wcyIsImxlbmd0aCIsImNyZWF0ZUluZmluaXRlQ29tcHV0ZXIiLCJwcmVsb2FkQmF0Y2hTaXplIiwicHJlbG9hZEFkZGl0aW9uYWxIZWlnaHQiLCJyZWNvbXB1dGVBcGVydHVyZVN0YXRlRnJvbU9wdGlvbnNBbmRTY3JvbGxUb3AiLCJlIiwiaGFuZGxlU2Nyb2xsIiwibWFuYWdlU2Nyb2xsVGltZW91dHMiLCJjbGVhclRpbWVvdXQiLCJ0aGF0Iiwic2V0VGltZW91dCIsIm5ld0FwZXJ0dXJlU3RhdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLDBDQUEwQyxHQUFoRDs7SUFFcUJDLFE7OztBQW1CcEIsbUJBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxrSEFDWkEsS0FEWTs7QUFBQTs7QUFFbEIsTUFBTUMsb0JBQW9CLE1BQUtDLCtCQUFMLENBQXFDRixLQUFyQyxDQUExQjs7QUFFQSxRQUFLRyxhQUFMLEdBQXFCRixrQkFBa0JFLGFBQXZDO0FBQ0EsUUFBS0MsS0FBTCxHQUFhSCxrQkFBa0JHLEtBQS9COztBQUVBLE1BQU1DLFFBQVFKLGtCQUFrQkssUUFBaEM7QUFDQUQsUUFBTUUsYUFBTixHQUFzQkMsU0FBdEI7QUFDQUgsUUFBTUksV0FBTixHQUFvQixLQUFwQjs7QUFFQSxRQUFLSixLQUFMLEdBQWFBLEtBQWI7QUFYa0I7QUFZbEI7Ozs7OztBQTRERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0Q0FFMEJLLFMsRUFBVztBQUNwQyxPQUFJVCxvQkFBb0IsS0FBS0MsK0JBQUwsQ0FBcUNRLFNBQXJDLENBQXhCOztBQUVBLFFBQUtQLGFBQUwsR0FBcUJGLGtCQUFrQkUsYUFBdkM7QUFDQSxRQUFLQyxLQUFMLEdBQWFILGtCQUFrQkcsS0FBL0I7O0FBRUEsUUFBS08sUUFBTCxDQUFjVixrQkFBa0JLLFFBQWhDO0FBQ0E7OzsyQkF3Q1E7QUFBQTs7QUFDUixPQUFJTSxxQkFBSjtBQUNBLE9BQUksS0FBS1AsS0FBTCxDQUFXUSxVQUFYLEdBQXdCLENBQTVCLEVBQStCO0FBQzlCRCxtQkFBZSxLQUFLVCxhQUFMLENBQW1CVyxRQUFuQixDQUE0QkMsS0FBNUIsQ0FDZCxLQUFLVixLQUFMLENBQVdXLGlCQURHLEVBRWQsS0FBS1gsS0FBTCxDQUFXWSxlQUFYLEdBQTZCLENBRmYsQ0FBZjtBQUlBLElBTEQsTUFLTztBQUNOTCxtQkFBZSxLQUFLVCxhQUFMLENBQW1CVyxRQUFsQztBQUNBOztBQUVELE9BQUlJLHVCQUF1QixFQUEzQjtBQUNBLE9BQUksS0FBS2IsS0FBTCxDQUFXSSxXQUFmLEVBQTRCO0FBQzNCUyx5QkFBcUJDLGFBQXJCLEdBQXFDLE1BQXJDO0FBQ0E7O0FBRUQsT0FBSUMsa0JBQWtCLEtBQUtmLEtBQUwsQ0FBV2dCLGdCQUFYLENBQTRCQyxrQkFBNUIsQ0FBK0MsS0FBS2pCLEtBQUwsQ0FBV1csaUJBQTFELENBQXRCO0FBQUEsT0FDQ08scUJBQXFCLEtBQUtsQixLQUFMLENBQVdnQixnQkFBWCxDQUE0QkcscUJBQTVCLENBQWtELEtBQUtuQixLQUFMLENBQVdZLGVBQTdELENBRHRCOztBQUdBO0FBQ0E7QUFDQSxVQUNDO0FBQUE7QUFBQTtBQUNDLGdCQUFXLEtBQUtkLGFBQUwsQ0FBbUJzQixTQUQvQjtBQUVDLFVBQUssZ0JBQUs7QUFDVCxhQUFLQyxVQUFMLEdBQWtCQyxDQUFsQjtBQUNBLE1BSkY7QUFLQyxZQUFPLEtBQUt2QixLQUFMLENBQVd3QixvQkFBWCxFQUxSO0FBTUMsZUFBVSxLQUFLeEIsS0FBTCxDQUFXeUI7QUFOdEI7QUFRQztBQUFBO0FBQUE7QUFDQyxXQUFLLGdCQUFLO0FBQ1QsY0FBS0Msc0JBQUwsR0FBOEJILENBQTlCO0FBQ0EsT0FIRjtBQUlDLGFBQU9UO0FBSlI7QUFNQztBQUNDLFdBQUssZ0JBQUs7QUFDVCxjQUFLYSxTQUFMLEdBQWlCSixDQUFqQjtBQUNBLE9BSEY7QUFJQyxhQUFPLDBCQUFnQkssZ0JBQWhCLENBQWlDWixlQUFqQztBQUpSLE9BTkQ7QUFZRVIsaUJBWkY7QUFjQztBQUNDLFdBQUssZ0JBQUs7QUFDVCxjQUFLcUIsWUFBTCxHQUFvQk4sQ0FBcEI7QUFDQSxPQUhGO0FBSUMsYUFBTywwQkFBZ0JLLGdCQUFoQixDQUFpQ1Qsa0JBQWpDO0FBSlI7QUFkRDtBQVJELElBREQ7QUFnQ0E7Ozs7RUF4TW9DLGdCQUFNVyxTOztBQUF2Qm5DLFEsQ0FDYm9DLFMsR0FBWTtBQUNsQnJCLFdBQVUsb0JBQVVzQixHQURGO0FBRWxCQyxPQUFNLG9CQUFVQyxLQUZFO0FBR2xCQyxnQkFBZSxvQkFBVUMsTUFBVixDQUFpQkMsVUFIZDtBQUlsQkMsa0JBQWlCLG9CQUFVRixNQUFWLENBQWlCQyxVQUpoQjtBQUtsQmhCLFlBQVcsb0JBQVVrQixNQUxIO0FBTWxCQyxTQUFRLG9CQUFVQyxLQUFWLENBQWdCO0FBQ3ZCQyxtQkFBaUIsb0JBQVVDO0FBREosRUFBaEIsRUFFTE4sVUFSZTtBQVNsQk8sa0JBQWlCLG9CQUFVQztBQVRULEM7QUFEQ2xELFEsQ0FhYm1ELFksR0FBZTtBQUNyQnpCLFlBQVcsRUFEVTtBQUVyQm1CLFNBQVEsRUFGYTtBQUdyQkksa0JBQWlCLDJCQUFNLENBQUU7QUFISixDOzs7OztNQW9CdEJHLGdDLEdBQW1DLFlBQU07QUFDeEMsTUFBSUMsWUFBWSxFQUFoQjs7QUFFQUEsWUFBVXZCLGtCQUFWLEdBQStCLE9BQUt3QixvQkFBcEM7QUFDQUQsWUFBVUUsWUFBVixHQUF5QixZQUFNO0FBQzlCLFVBQU8sT0FBSzVCLFVBQUwsR0FBa0IsT0FBS0EsVUFBTCxDQUFnQjZCLFNBQWxDLEdBQThDLENBQXJEO0FBQ0EsR0FGRDs7QUFJQUgsWUFBVUksWUFBVixHQUF5QixlQUFPO0FBQy9CLE9BQUksT0FBSzlCLFVBQVQsRUFBcUI7QUFDcEIsV0FBS0EsVUFBTCxDQUFnQjZCLFNBQWhCLEdBQTRCRSxHQUE1QjtBQUNBO0FBQ0QsR0FKRDtBQUtBTCxZQUFVTSxxQkFBVixHQUFrQztBQUFBLFVBQVNDLE1BQU1DLE1BQU4sS0FBaUIsT0FBS2xDLFVBQS9CO0FBQUEsR0FBbEM7O0FBRUEwQixZQUFVeEIsb0JBQVYsR0FBaUMsWUFBTTtBQUN0QyxVQUFPaUMsT0FBT0MsTUFBUCxDQUNOLEVBRE0sRUFFTjtBQUNDQyxZQUFRLE9BQUs1RCxhQUFMLENBQW1CdUMsZUFENUI7QUFFQ3NCLGVBQVcsUUFGWjtBQUdDQyxlQUFXLFFBSFo7QUFJQ0MsNkJBQXlCO0FBSjFCLElBRk0sRUFRTixPQUFLL0QsYUFBTCxDQUFtQnlDLE1BQW5CLENBQTBCRSxlQUExQixJQUE2QyxFQVJ2QyxDQUFQO0FBVUEsR0FYRDs7QUFhQSxTQUFPTSxTQUFQO0FBQ0EsRTs7TUFFRGxELCtCLEdBQWtDLGlCQUFTO0FBQzFDLE1BQUlDLGdCQUFnQiwwQkFBZ0JnRSxxQkFBaEIsQ0FBc0NuRSxLQUF0QyxDQUFwQjtBQUNBLE1BQUlJLFFBQVEsT0FBSytDLGdDQUFMLEVBQVo7O0FBRUEsTUFBSTdDLFdBQVcsRUFBZjs7QUFFQUEsV0FBU08sVUFBVCxHQUFzQlYsY0FBY2tDLElBQWQsQ0FBbUIrQixNQUF6QztBQUNBOUQsV0FBU2UsZ0JBQVQsR0FBNEIsMEJBQWdCZ0Qsc0JBQWhCLENBQzNCbEUsY0FBY29DLGFBRGEsRUFFM0JwQyxjQUFja0MsSUFGYSxDQUE1Qjs7QUFLQS9CLFdBQVNnRSxnQkFBVCxHQUE0Qm5FLGNBQWNtRSxnQkFBMUM7QUFDQWhFLFdBQVNpRSx1QkFBVCxHQUFtQ3BFLGNBQWNvRSx1QkFBakQ7O0FBRUFqRSxhQUFXdUQsT0FBT0MsTUFBUCxDQUNWeEQsUUFEVSxFQUVWLDBCQUFnQmtFLDZDQUFoQixDQUE4RGxFLFFBQTlELEVBQXdFRixNQUFNa0QsWUFBTixFQUF4RSxDQUZVLENBQVg7O0FBS0EsU0FBTztBQUNObkQsK0JBRE07QUFFTkMsZUFGTTtBQUdORTtBQUhNLEdBQVA7QUFLQSxFOztNQW9CRCtDLG9CLEdBQXVCLGFBQUs7QUFDM0IsTUFBSSxPQUFLakQsS0FBTCxDQUFXc0QscUJBQVgsQ0FBaUNlLENBQWpDLENBQUosRUFBeUM7QUFDeEM7QUFDQTs7QUFFRCxTQUFLQyxZQUFMLENBQWtCLE9BQUt0RSxLQUFMLENBQVdrRCxZQUFYLEVBQWxCO0FBQ0EsRTs7TUFFRHFCLG9CLEdBQXVCLFlBQU07QUFDNUI7QUFDQTs7QUFFQSxNQUFJLE9BQUt0RSxLQUFMLENBQVdFLGFBQWYsRUFBOEI7QUFDN0JxRSxnQkFBYSxPQUFLdkUsS0FBTCxDQUFXRSxhQUF4QjtBQUNBOztBQUVELE1BQUlzRSxhQUFKO0FBQUEsTUFDQ3RFLGdCQUFnQnVFLFdBQVcsWUFBTTtBQUNoQ0QsUUFBS2xFLFFBQUwsQ0FBYztBQUNiRixpQkFBYSxLQURBO0FBRWJGLG1CQUFlQztBQUZGLElBQWQ7QUFJQSxHQUxlLEVBS2JWLHVDQUxhLENBRGpCOztBQVFBLFNBQUthLFFBQUwsQ0FBYztBQUNiRixnQkFBYSxJQURBO0FBRWJGLGtCQUFlQTtBQUZGLEdBQWQ7QUFJQSxFOztNQUVEbUUsWSxHQUFlLHFCQUFhO0FBQzNCLFNBQUtDLG9CQUFMOztBQUVBLE1BQUlJLG1CQUFtQiwwQkFBZ0JQLDZDQUFoQixDQUE4RCxPQUFLbkUsS0FBbkUsRUFBMEVrRCxTQUExRSxDQUF2QjtBQUNBO0FBQ0EsU0FBSzVDLFFBQUwsQ0FBY2tELE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCaUIsZ0JBQWxCLENBQWQ7QUFDQSxFOzs7a0JBakptQmhGLFEiLCJmaWxlIjoicmVhY3QtaW5maW5pdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBpc0VxdWFsIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcblxuaW1wb3J0IGluZmluaXRlSGVscGVycyBmcm9tICcuL3V0aWxzL2luZmluaXRlSGVscGVycyc7XG5cbmNvbnN0IHRpbWVTY3JvbGxTdGF0ZUxhc3RzRm9yQWZ0ZXJVc2VyU2Nyb2xscyA9IDE1MDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5maW5pdGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgcHJvcFR5cGVzID0ge1xuXHRcdGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuXHRcdGRhdGE6IFByb3BUeXBlcy5hcnJheSxcblx0XHRlbGVtZW50SGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cdFx0Y29udGFpbmVySGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG5cdFx0Y2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXHRcdHN0eWxlczogUHJvcFR5cGVzLnNoYXBlKHtcblx0XHRcdHNjcm9sbGFibGVTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcblx0XHR9KS5pc1JlcXVpcmVkLFxuXHRcdG9uVmlzaWJsZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cdH07XG5cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjbGFzc05hbWU6ICcnLFxuXHRcdHN0eWxlczoge30sXG5cdFx0b25WaXNpYmxlQ2hhbmdlOiAoKSA9PiB7fSxcblx0fTtcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0XHRjb25zdCBuZXh0SW50ZXJuYWxTdGF0ZSA9IHRoaXMucmVjb21wdXRlSW50ZXJuYWxTdGF0ZUZyb21Qcm9wcyhwcm9wcyk7XG5cblx0XHR0aGlzLmNvbXB1dGVkUHJvcHMgPSBuZXh0SW50ZXJuYWxTdGF0ZS5jb21wdXRlZFByb3BzO1xuXHRcdHRoaXMudXRpbHMgPSBuZXh0SW50ZXJuYWxTdGF0ZS51dGlscztcblxuXHRcdGNvbnN0IHN0YXRlID0gbmV4dEludGVybmFsU3RhdGUubmV3U3RhdGU7XG5cdFx0c3RhdGUuc2Nyb2xsVGltZW91dCA9IHVuZGVmaW5lZDtcblx0XHRzdGF0ZS5pc1Njcm9sbGluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xuXHR9XG5cblx0Z2VuZXJhdGVDb21wdXRlZFV0aWxpdHlGdW5jdGlvbnMgPSAoKSA9PiB7XG5cdFx0bGV0IHV0aWxpdGllcyA9IHt9O1xuXG5cdFx0dXRpbGl0aWVzLm5vZGVTY3JvbGxMaXN0ZW5lciA9IHRoaXMuaW5maW5pdGVIYW5kbGVTY3JvbGw7XG5cdFx0dXRpbGl0aWVzLmdldFNjcm9sbFRvcCA9ICgpID0+IHtcblx0XHRcdHJldHVybiB0aGlzLnNjcm9sbGFibGUgPyB0aGlzLnNjcm9sbGFibGUuc2Nyb2xsVG9wIDogMDtcblx0XHR9O1xuXG5cdFx0dXRpbGl0aWVzLnNldFNjcm9sbFRvcCA9IHRvcCA9PiB7XG5cdFx0XHRpZiAodGhpcy5zY3JvbGxhYmxlKSB7XG5cdFx0XHRcdHRoaXMuc2Nyb2xsYWJsZS5zY3JvbGxUb3AgPSB0b3A7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR1dGlsaXRpZXMuc2Nyb2xsU2hvdWxkQmVJZ25vcmVkID0gZXZlbnQgPT4gZXZlbnQudGFyZ2V0ICE9PSB0aGlzLnNjcm9sbGFibGU7XG5cblx0XHR1dGlsaXRpZXMuYnVpbGRTY3JvbGxhYmxlU3R5bGUgPSAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihcblx0XHRcdFx0e30sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRoZWlnaHQ6IHRoaXMuY29tcHV0ZWRQcm9wcy5jb250YWluZXJIZWlnaHQsXG5cdFx0XHRcdFx0b3ZlcmZsb3dYOiAnaGlkZGVuJyxcblx0XHRcdFx0XHRvdmVyZmxvd1k6ICdzY3JvbGwnLFxuXHRcdFx0XHRcdFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiAndG91Y2gnLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGlzLmNvbXB1dGVkUHJvcHMuc3R5bGVzLnNjcm9sbGFibGVTdHlsZSB8fCB7fVxuXHRcdFx0KTtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHV0aWxpdGllcztcblx0fTtcblxuXHRyZWNvbXB1dGVJbnRlcm5hbFN0YXRlRnJvbVByb3BzID0gcHJvcHMgPT4ge1xuXHRcdGxldCBjb21wdXRlZFByb3BzID0gaW5maW5pdGVIZWxwZXJzLmdlbmVyYXRlQ29tcHV0ZWRQcm9wcyhwcm9wcyk7XG5cdFx0bGV0IHV0aWxzID0gdGhpcy5nZW5lcmF0ZUNvbXB1dGVkVXRpbGl0eUZ1bmN0aW9ucygpO1xuXG5cdFx0bGV0IG5ld1N0YXRlID0ge307XG5cblx0XHRuZXdTdGF0ZS5kYXRhTGVuZ3RoID0gY29tcHV0ZWRQcm9wcy5kYXRhLmxlbmd0aDtcblx0XHRuZXdTdGF0ZS5pbmZpbml0ZUNvbXB1dGVyID0gaW5maW5pdGVIZWxwZXJzLmNyZWF0ZUluZmluaXRlQ29tcHV0ZXIoXG5cdFx0XHRjb21wdXRlZFByb3BzLmVsZW1lbnRIZWlnaHQsXG5cdFx0XHRjb21wdXRlZFByb3BzLmRhdGFcblx0XHQpO1xuXG5cdFx0bmV3U3RhdGUucHJlbG9hZEJhdGNoU2l6ZSA9IGNvbXB1dGVkUHJvcHMucHJlbG9hZEJhdGNoU2l6ZTtcblx0XHRuZXdTdGF0ZS5wcmVsb2FkQWRkaXRpb25hbEhlaWdodCA9IGNvbXB1dGVkUHJvcHMucHJlbG9hZEFkZGl0aW9uYWxIZWlnaHQ7XG5cblx0XHRuZXdTdGF0ZSA9IE9iamVjdC5hc3NpZ24oXG5cdFx0XHRuZXdTdGF0ZSxcblx0XHRcdGluZmluaXRlSGVscGVycy5yZWNvbXB1dGVBcGVydHVyZVN0YXRlRnJvbU9wdGlvbnNBbmRTY3JvbGxUb3AobmV3U3RhdGUsIHV0aWxzLmdldFNjcm9sbFRvcCgpKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29tcHV0ZWRQcm9wcyxcblx0XHRcdHV0aWxzLFxuXHRcdFx0bmV3U3RhdGUsXG5cdFx0fTtcblx0fTtcblxuXHQvLyBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcblx0Ly8gXHRjb25zb2xlLmxvZyghaXNFcXVhbCh0aGlzLnByb3BzLmNoaWxkcmVuLCBuZXh0UHJvcHMuY2hpbGRyZW4pKTtcblx0Ly8gXHRyZXR1cm4gdGhpcy5wcm9wcy5jb250YWluZXJIZWlnaHQgIT09IG5leHRQcm9wcy5jb250YWluZXJIZWlnaHRcblx0Ly8gXHRcdHx8IHRoaXMucHJvcHMuZWxlbWVudEhlaWdodCAhPT0gbmV4dFByb3BzLmVsZW1lbnRIZWlnaHRcblx0Ly8gXHRcdHx8ICFpc0VxdWFsKHRoaXMucHJvcHMuZGF0YSwgbmV4dFByb3BzLmRhdGEpXG5cdC8vIFx0XHQvLyB8fCAhaXNFcXVhbCh0aGlzLnByb3BzLmNoaWxkcmVuLCBuZXh0UHJvcHMuY2hpbGRyZW4pXG5cdC8vIFx0XHR8fCAhaXNFcXVhbCh0aGlzLnN0YXRlLCBuZXh0U3RhdGUpO1xuXHQvLyB9XG5cblx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRsZXQgbmV4dEludGVybmFsU3RhdGUgPSB0aGlzLnJlY29tcHV0ZUludGVybmFsU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzKTtcblxuXHRcdHRoaXMuY29tcHV0ZWRQcm9wcyA9IG5leHRJbnRlcm5hbFN0YXRlLmNvbXB1dGVkUHJvcHM7XG5cdFx0dGhpcy51dGlscyA9IG5leHRJbnRlcm5hbFN0YXRlLnV0aWxzO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZShuZXh0SW50ZXJuYWxTdGF0ZS5uZXdTdGF0ZSk7XG5cdH1cblxuXHRpbmZpbml0ZUhhbmRsZVNjcm9sbCA9IGUgPT4ge1xuXHRcdGlmICh0aGlzLnV0aWxzLnNjcm9sbFNob3VsZEJlSWdub3JlZChlKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFuZGxlU2Nyb2xsKHRoaXMudXRpbHMuZ2V0U2Nyb2xsVG9wKCkpO1xuXHR9O1xuXG5cdG1hbmFnZVNjcm9sbFRpbWVvdXRzID0gKCkgPT4ge1xuXHRcdC8vIE1haW50YWlucyBhIHNlcmllcyBvZiB0aW1lb3V0cyB0byBzZXQgdGhpcy5zdGF0ZS5pc1Njcm9sbGluZ1xuXHRcdC8vIHRvIGJlIHRydWUgd2hlbiB0aGUgZWxlbWVudCBpcyBzY3JvbGxpbmcuXG5cblx0XHRpZiAodGhpcy5zdGF0ZS5zY3JvbGxUaW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5zdGF0ZS5zY3JvbGxUaW1lb3V0KTtcblx0XHR9XG5cblx0XHRsZXQgdGhhdCA9IHRoaXMsXG5cdFx0XHRzY3JvbGxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdHRoYXQuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdGlzU2Nyb2xsaW5nOiBmYWxzZSxcblx0XHRcdFx0XHRzY3JvbGxUaW1lb3V0OiB1bmRlZmluZWQsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgdGltZVNjcm9sbFN0YXRlTGFzdHNGb3JBZnRlclVzZXJTY3JvbGxzKTtcblxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXNTY3JvbGxpbmc6IHRydWUsXG5cdFx0XHRzY3JvbGxUaW1lb3V0OiBzY3JvbGxUaW1lb3V0LFxuXHRcdH0pO1xuXHR9O1xuXG5cdGhhbmRsZVNjcm9sbCA9IHNjcm9sbFRvcCA9PiB7XG5cdFx0dGhpcy5tYW5hZ2VTY3JvbGxUaW1lb3V0cygpO1xuXG5cdFx0bGV0IG5ld0FwZXJ0dXJlU3RhdGUgPSBpbmZpbml0ZUhlbHBlcnMucmVjb21wdXRlQXBlcnR1cmVTdGF0ZUZyb21PcHRpb25zQW5kU2Nyb2xsVG9wKHRoaXMuc3RhdGUsIHNjcm9sbFRvcCk7XG5cdFx0Ly8gdGhpcy5wcm9wcy5vblZpc2libGVDaGFuZ2UobmV3QXBlcnR1cmVTdGF0ZSk7XG5cdFx0dGhpcy5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBuZXdBcGVydHVyZVN0YXRlKSk7XG5cdH07XG5cblx0cmVuZGVyKCkge1xuXHRcdGxldCBkaXNwbGF5YWJsZXM7XG5cdFx0aWYgKHRoaXMuc3RhdGUuZGF0YUxlbmd0aCA+IDEpIHtcblx0XHRcdGRpc3BsYXlhYmxlcyA9IHRoaXMuY29tcHV0ZWRQcm9wcy5jaGlsZHJlbi5zbGljZShcblx0XHRcdFx0dGhpcy5zdGF0ZS5kaXNwbGF5SW5kZXhTdGFydCxcblx0XHRcdFx0dGhpcy5zdGF0ZS5kaXNwbGF5SW5kZXhFbmQgKyAxXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5YWJsZXMgPSB0aGlzLmNvbXB1dGVkUHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXG5cdFx0bGV0IGluZmluaXRlU2Nyb2xsU3R5bGVzID0ge307XG5cdFx0aWYgKHRoaXMuc3RhdGUuaXNTY3JvbGxpbmcpIHtcblx0XHRcdGluZmluaXRlU2Nyb2xsU3R5bGVzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdFx0fVxuXG5cdFx0bGV0IHRvcFNwYWNlckhlaWdodCA9IHRoaXMuc3RhdGUuaW5maW5pdGVDb21wdXRlci5nZXRUb3BTcGFjZXJIZWlnaHQodGhpcy5zdGF0ZS5kaXNwbGF5SW5kZXhTdGFydCksXG5cdFx0XHRib3R0b21TcGFjZXJIZWlnaHQgPSB0aGlzLnN0YXRlLmluZmluaXRlQ29tcHV0ZXIuZ2V0Qm90dG9tU3BhY2VySGVpZ2h0KHRoaXMuc3RhdGUuZGlzcGxheUluZGV4RW5kKTtcblxuXHRcdC8vIHRvcFNwYWNlciBhbmQgYm90dG9tU3BhY2VyIHRha2UgdXAgdGhlIGFtb3VudCBvZiBzcGFjZSB0aGF0IHRoZVxuXHRcdC8vIHJlbmRlcmVkIGVsZW1lbnRzIHdvdWxkIGhhdmUgdGFrZW4gdXAgb3RoZXJ3aXNlXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXZcblx0XHRcdFx0Y2xhc3NOYW1lPXt0aGlzLmNvbXB1dGVkUHJvcHMuY2xhc3NOYW1lfVxuXHRcdFx0XHRyZWY9e2MgPT4ge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsYWJsZSA9IGM7XG5cdFx0XHRcdH19XG5cdFx0XHRcdHN0eWxlPXt0aGlzLnV0aWxzLmJ1aWxkU2Nyb2xsYWJsZVN0eWxlKCl9XG5cdFx0XHRcdG9uU2Nyb2xsPXt0aGlzLnV0aWxzLm5vZGVTY3JvbGxMaXN0ZW5lcn1cblx0XHRcdD5cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdHJlZj17YyA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnNtb290aFNjcm9sbGluZ1dyYXBwZXIgPSBjO1xuXHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0c3R5bGU9e2luZmluaXRlU2Nyb2xsU3R5bGVzfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0cmVmPXtjID0+IHtcblx0XHRcdFx0XHRcdFx0dGhpcy50b3BTcGFjZXIgPSBjO1xuXHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdHN0eWxlPXtpbmZpbml0ZUhlbHBlcnMuYnVpbGRIZWlnaHRTdHlsZSh0b3BTcGFjZXJIZWlnaHQpfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0e2Rpc3BsYXlhYmxlc31cblx0XHRcdFx0XHR7Lyp7dGhpcy5wcm9wcy5jaGlsZHJlbn0qL31cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRyZWY9e2MgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmJvdHRvbVNwYWNlciA9IGM7XG5cdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdFx0c3R5bGU9e2luZmluaXRlSGVscGVycy5idWlsZEhlaWdodFN0eWxlKGJvdHRvbVNwYWNlckhlaWdodCl9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG4iXX0=